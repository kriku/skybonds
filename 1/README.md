### Использование

Прогнать тесты

```sh
npm install
npm run test
```

Собрать данные

```sh
# npm run build (выполняется в postinstall)
mkdir data
./.benchmark.sh
```
Нарисовать графики (требуется установить `gnuplot`)

```sh
./.plots.sh
```

## Подсчет долей

### Первичная оценка трудозатрат

Объяснение используемой шкалы:
- зависимость не линейная
- 1 - минутное дело, 10 - месяц работы 

Субъективная сложность - 5 (около 1 человеко-день).

Для решение данного алгоритмического задания хорошо подойдёт TDD

Далее все оценки будут в попугаях [1, 2, 3, 5, 8].

### План:

- этап 1
  - первичная инициализации и создание окружения - 1
  - написание тесткейсов - 2
  - реализация функции подсчета - 2

- этап 2
  - формирование окружения для нагрузочного тестирования - 2
  - анализ решения - 1
  
- UPD: этап 3 (не учел сразу)
  - сбор и подготовка данных - 2
  - формирование отчета - 2
  - построение графиков - 2

### Первичная оценка алгоритма

Меньше чем за "обойти все элементы" - выполнить не получится.

Алгоритмическая сложность - **O(n)**.

Сложность по памяти - **O(n)**.

Соответственно и по памяти - линейная зависимость от количества элементов.

Операции вставки / удаления - **O(n)** - требуется пересчитать все доли.

Единственная, как мне кажется, оптимизация - уменьшение коэффициента **k**, который зависит уже от реализации алгоритма. Эту часть рассмотрим при нагрузочном тестировании.

### Этап 1

Описал зависимости окружения разработки:

  * typescript - для статической типизации кода, как технологию дефакто.

  * jest, @types/jest, ts-jest - для написания тестов с использованием того же typescript.

Описал типы интерфейсов функции, описал 4 тест-кейса, имплементировал логику в функциональном стиле, в пять прогонов - без какой либо оптимизации.

[подробный отчет](./EPISODE1.md)

### Этап 2

Описал процесс генерирующий корректные входные данные, вызывающий подсчет долей - `index.proc.ts`. 
В результате процесс сообщает данные собранных метрик в stdout.

Описал создание нагрузки из процессов в форках, по параметрам из аргументов командной строки - `index.load.ts`.
В результате на собранных метриках считается среднее, формируется в csv формат.

Описал последовательные запуски с разными параметрами, сбор данных для анализа - `.benchmark.sh`.
Описал построение графиков на csv данных - `*.gnuplot`, `.plots.sh`.

[подробный отчет](./EPISODE2.md)

### Итого

С первоначальной оценкой ошибся, ровно на:
- описание графиков в gnuplot (new) - ~2ч
- сбор данных, скриншотов, написание отчета - ~6ч

(короче в два раза ошибся с оценкой)

Не взял в расчет с самого начала, как я буду собирать метрики, рисовать графики, составлять отчет.

Угадал с простотой gnuplot, не закопался.
